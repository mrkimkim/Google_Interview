#-*- coding: utf-8 -*-
# 구글 면접 대비 0 - 상호배제

"""
기본 출처 : https://practice.geeksforgeeks.org/problems/mutual-exclusion-and-race-condition/

크리티컬 섹션 / 뮤텍스 / 세마포어의 정의와 차이에 대해 알아본다.

[프로세스]
- 프로그램과 구분되는 것으로 프로그램이 실행되어 메모리에 로드된 것을
프로세스라고 부른다. OS로부터 자원들 할당받는 작업의 단위

[스레드]
- 스레드는 실행의 최소 단위로 프로세스가 OS로부터 받은 자원을 이용한다.

[멀티스레드의 필요성]
- 모든 프로세스는 최소 하나의 메인 스레드를 가지고 있다. 여러 작업을
동시에 수행할 때 프로세스를 여러 개 생성하여 수행할 수 있지만, 프로세스
는 OS로부터 자원을 할당받는 것으로 시스템 콜을 요청하는 시간이 들고,
하나의 프로세스에서 다른 프로세스로 전환하는 컨텍스트 스위칭의 오버헤드
가 크기 때문에 멀티스레드를 멀티 프로세스로 구현하는 것은 자원 낭비다.

[멀티스레드]
- 하나의 프로세스 내에서 여러개의 스레드가 실행되는 것이다. 물론 CPU가
하나인 상황을 가정하면 한 번에 하나의 스레드만 실행된다. 어떤 스레드가
실행되는 도중에 다른 스레드 B가 실행되는 경우가 당연히 발생한다. 여기서
각 스레드는 코드, 데이터, 힙 영역을 공유하고 스택 영역만 별도로 가진다.

[멀티프로세스]
- 각 프로세스는 독자적인 Code, Data, Heap, Stack 영역을 가지고
환경 변수나 프로세스 핸들 테이블만 공유한다. 프로세스간 통신은 IPC를
통해야한다. IPC는 (IPC, 세마포어, 큐, 공유메모리)이다. 멀티 프로세스
환경에서는 한 프로세스의 실패가 다른 프로세스에 영향을 미치지 않는다.
반면 멀티스레드에서는 한 스레드의 실패는 프로세스를 중단시켜 다른 스
레드까지 멈추게하는 결과를 초래해 위험이 더욱 크다.

[스레드 스위칭]
- 컨텍스트 스위칭은 멀티스레드와 멀티프로세스 모두에서 발생한다.
동일 프로세스 내에서의 스레드 간 스위칭은 레지스터 교환만 발생하므로
프로세스 스위칭보다 오버헤드가 적다.

[프로세스 상태 전이]
- 프로세스의 상태는
New(생성) : 실행되어 Ready로 넘어간다.
Ready(준비) : 작업 스케줄러에 의해 선택된 프로세스가 실행단계로 넘어간다.
Running(실행) : 이 상태에서 인터럽트를 받으면 실행 중이던 프로세스는 Ready로 넘어가고
우선순위가 높은 프로세스가 실행 상태로 전이된다.
Block(대기) : 현재 실행 중인 프로세스가 입출력 처리를 해야 할 때 프로세스는 실행단계
에서 Block으로 넘어간다. 이 때 Ready 이던 다른 프로세스가 Runnning으로 넘어간다.
Block 상태의 프로세스는 우선 순위가 부여되지 않고 입출력 처리가 끝났을 때 Ready로
넘어간다. 입출력은 IO 장치가 하는 일이다.
Terminated(종료)
의 다섯 단계로 나뉜다.

[컨텍스트 스위칭]
- 프로세스 B가 Ready -> Running, 프로세스 A가 Running, Ready로 넘어가는
과정에서 A의 상태 값 및 레지스터는 PCB(Process Control Block)에 저장되고
PCB의 B의 정보는 CPU로 적재된다.
- User -> Kernel Mode -> PCB Save -> Process Choose -> PCB Load -> User Level

- 프로세스의 Context Switching에서는 Virtual Memory가 전환된다. 메모리 캐시의 내용
들도 다른 프로세스에게는 의미없어진다.

[가상 메모리]
- 모든 프로세스는 사용가능한 최대의 메모리를 쓰고 싶어한다.
멀티 프로세스 환경에서는 RAM이 한정되거나 필요한 메모리 용량보다 작을 수 있어
이를 위해서 사용하는 것이 HDD나 SDD같은 보조기억장치의 메모리를 사용한다.
- 또한 RAM은 하나의 프로세스를 위해 전부 사용되는 것이 아니라 프로세스
마다 쪼개서 사용하는 형태이므로 코드 상의 메모리주소를 RAM의 실제 물리
주소에 매칭해서 쓸 수가 없다. 따라서 CPU에서 RAM의 메모리를 참조할 때
는 직접 매칭이 아니라 MMU라는 Memory Management Unit을 사용하고 CPU
는 현재 프로세스에서 사용하는 가상 메모리 주소를 MMU에 전달해 MMU에서
RAM의 해당 페이지를 찾은 후 RAM의 물리 주소에 접근해 데이터를 읽어온다.

TLB는 캐시메모리로 최근에 참조한 Entry 저장
TTB는 변환 Page Table이 존재하는 DRAM Memory의 Base Address로
MMU에 명시되어 있음.

[Page Fault]
- TLS Miss일 때 메인 메모리에 Page가 없으면 페이지 폴트가 발생하고
OS는 Disk를 Access해서 Main Memory로 데이터를 가져와야한다. 이 작업은
IO 작업이므로 OS는 현재 프로세스를 대기상태로 옮긴다.

[Segment Fault]
- 프로세스가 허용되지 않은 메모리 영역에 접근을 시도할 때 발생한다.
- C에서 포인터를 쓸 때 발생하는 예가 있는데 포인터 초기화하지 않을
경우 발생한다.

[메모리 접근]
- CPU -> MMU -> TLB -> (miss) -> RAM TTB -> DRAM Access ->
(Page Fault) -> Disk IO, Process Block -> Context Switching
-> Disk IO Finish, Process Ready -> Context Switching
-> TLB -> Miss -> RAM TTB -> DRAM Access -> TLB -> TLB Hit -> DRAM Access

[리소스]
- 어떤 것이든 가능하다. 변수, 힙의 오브젝트, 파일 핸들, 네트워크 소켓 등

[크리티컬 섹션]
- 멀티스레드인 프로로세스에서 여러 스레드가 동일한 리소스에 접근할 수 있다.
따라서 한 스레드가 다른 데이터를 읽는 동안 다른 스레드가 쓰기를 시도할 수도
있다. 이런 상황은 경쟁조건(race condition)이며 이를 방기하기 위해 크리티컬
섹션을 정의하여 막아낸다. 크리티컬 섹션은 단일 프로세스 안에서만 스레드들에
대해서만 유효하다.

[뮤텍스]
- 뮤텍스는 상호배제 Mutual Exclution이라고 하는데, 이런 매커니즘에서
어떤 스레드가 공유자원에 접근할 때 다른 어떤 프로세스의 스레드도 공유자원
에 대한 접근을 막는 것이다.

[세마포어]
- 세마포어는 뮤텍스와 유사하지만 Counter 값을 가진다. 이는 얼마나 많은
스레드가 동시에 동일 자원을 점유할 수 있는지를 정의하는 것이다. 스레드가
크리티컬 섹션에 진입하면 세마포어의 카운트가 감소하며 나올 때 증가한다.

[데드락의 조건]
- 비선점 프로그래밍 (프로세스가 자원 사용이 끝날 때까지 다른 프로세스가 이것을 뺏을 수 없다)
- 순환 자원 참조 (프로세스가 요구하는 자원으로 그래프를 만들면 사이클이 발생한다.)
- 상호배제 (프로세스가 자원을 요구하는 상태에서 배타적인 통제권을 가진다.)
- 점유 대기 (할당된 자원을 가진 상태에서 다른 자원을 기다린다.)
"""